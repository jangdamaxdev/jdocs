---
description: Hướng dẫn này cung cấp cái nhìn chi tiết về các chức năng của rete-connection-plugin, cho phép người dùng tương tác với connection trong ứng dụng web của bạn
keywords: connections,interaction
---

# Connections

::alert
Hướng dẫn này dựa trên [Basic](/docs/guides/basic). Bạn nên xem qua để hiểu tổng thể trước khi đọc hướng dẫn này.
::
::references
:ref-guide{title="Validation" link="/docs/guides/validation#connections-validation"}
:ref-example{title="Chatbot" link="/examples/chatbot"}
::

Hướng dẫn này cung cấp cái nhìn chi tiết hơn về các chức năng của plugin rete-connection-plugin, cho phép người dùng tương tác với connection.

Khi người dùng click vào một socket, connection kéo theo con trỏ được gọi là pseudo-connection, là một object có thêm thuộc tính `isPseudo: true`.

## Presets {#presets}

Bạn có thể đã thấy cách sử dụng preset sau, cho phép người dùng thêm connection bằng cách click/nhấn vào socket input/output và click/thả vào socket output/input:

```ts
connection.addPreset(ConnectionPresets.classic.setup());
```

Cách này tương đương với đoạn code dưới đây:

```ts
import { ClassicFlow } from "rete-connection-plugin";

connection.addPreset(() => new ClassicFlow());
```

Nếu socket input đã được kết nối, click hoặc nhấn vào nó sẽ xóa connection và thay thế bằng pseudo-connection.

### Custom preset {#custom-preset}

Nếu bạn muốn cách thêm connection khác, có thể dùng `BidirectFlow`. Ở chế độ này, thêm node bằng cách click vào socket input/output và kéo pseudo-connection tới socket đối diện.

```ts
import { ClassicFlow } from "rete-connection-plugin";

connection.addPreset(() => new BidirectFlow());
```

Ngoài ra, sử dụng dữ liệu socket ban đầu, bạn có thể chọn flow cụ thể hoặc vô hiệu hóa tương tác với socket nhất định

```ts
connection.addPreset(({ nodeId, side, key }) => {
  if (isReadonly(nodeId, side, key)) return undefined;
  if (usesBidirect(nodeId, side, key)) return new BidirectFlow();
  return new ClassicFlow();
});
```

Nếu các workflow có sẵn không đáp ứng nhu cầu, bạn có thể tự triển khai bằng cách tham khảo [mã nguồn](https://github.com/retejs/connection-plugin/blob/next/src/flow/builtin/bidirect.ts) của các flow hiện tại.

## Nâng cao hành vi {#enhanced-behavior}

Nâng cao hành vi của preset hiện tại có thể thực hiện bằng cách theo dõi các sự kiện `connectionpick` và `connectiondrop`

```ts
connection.addPipe((context) => {
  if (context.type === "connectionpick") {
    // khi người dùng click vào socket
    const { socket } = context.data;
  }
  if (context.type === "connectiondrop") {
    // khi người dùng click vào socket hoặc bất kỳ vùng nào
    const { socket, initial, created } = context.data;
  }
  return context;
});
```

Sự kiện `connectionpick` có thể bị ngăn chặn

```ts
connection.addPipe((context) => {
  if (context.type === "connectionpick") {
    if (readonly) return;
  }
  return context;
});
```

## Connection do người dùng tạo {#user-created-connection}

Mặc định, khi người dùng tạo connection qua UI, plugin sẽ thêm connection dưới dạng object, không phải instance của class như `ClassicPreset.Connection`. Nếu muốn tùy chỉnh quá trình thêm connection này, hãy chỉ định option `makeConnection` trong `ClassicFlow` hoặc `BidirectFlow`.

```ts
import { getSourceTarget } from "rete-connection-plugin";

connection.addPreset(
  () =>
    new ClassicFlow({
      makeConnection(from, to, context) {
        const [source, target] = getSourceTarget(from, to) || [null, null];
        const { editor } = context;

        if (source && target) {
          editor.addConnection(
            new MyConnection(
              editor.getNode(source.nodeId),
              source.key,
              editor.getNode(target.nodeId),
              target.key
            )
          );
          return true; // đảm bảo connection đã được thêm thành công
        }
      },
    })
);
```

Ngoài ra, việc sử dụng `getSourceTarget` là cần thiết, vì option `from` và `to` chứa dữ liệu về socket đầu và cuối, có thể không trùng với socket output và input.

## Cấu hình vị trí bắt đầu/kết thúc connection {#configure-connection-start-end}

Mỗi connection đều có điểm bắt đầu và kết thúc, kết nối trực tiếp với socket (trừ pseudo-connection, điểm kết thúc phụ thuộc vào vị trí con trỏ). Mặc định, cạnh phải của socket output là điểm bắt đầu, cạnh trái của socket input là điểm bắt đầu. Thay đổi kích thước socket sẽ làm thay đổi vị trí bắt đầu/kết thúc connection.

Để cấu hình vị trí bắt đầu/kết thúc connection, bạn có thể cung cấp `getDOMSocketPosition` với các tọa độ offset so với tâm socket. Phương thức này được dùng mặc định khi option `socketPositionWatcher` không được chỉ định.

```ts
import { getDOMSocketPosition } from "rete-render-utils";

render.addPreset(
  Presets.classic.setup({
    socketPositionWatcher: getDOMSocketPosition({
      offset({ x, y }, nodeId, side, key) {
        return {
          x: x + 10 * (side === "input" ? -1 : 1),
          y: y,
        };
      },
    }),
  })
);
```

Trong trường hợp này, việc tính toán vị trí socket dựa vào phần tử DOM. Có những trường hợp cách này không hiệu quả do hiệu năng hoặc các đặc thù triển khai (ví dụ trong [LOD example](/examples/lod) khi cần hiển thị connection ngay cả khi socket chưa có trong DOM).

Để sử dụng cách tính toán riêng cho vị trí bắt đầu/kết thúc connection, bạn có thể mở rộng class trừu tượng `BaseSocketPosition` và triển khai phương thức `calculatePosition`.

```ts
import { BaseSocketPosition } from 'rete-render-utils'

type Position = { x: number, y: number }
type Side = 'input' | 'output'

export class ComputedSocketPosition<S extends Schemes, K> extends BaseSocketPosition<S, K> {
  async calculatePosition(nodeId: string, side: Side, key: string): Promise<Position | null> {
    if (!this.area) return null

    return {
      x: side === 'input' ? 0 : getNodeWith(nodeId)
      y: 0
    }
  }
}

render.addPreset(Presets.classic.setup({
  socketPositionWatcher: new ComputedSocketPosition()
}))
```

Trong đó, `calculatePosition` cần trả về vị trí so với vị trí node, hoặc `null` nếu không thể tính toán
