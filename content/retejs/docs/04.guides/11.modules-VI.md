---
description: Tìm hiểu cách xây dựng các node Module xử lý đồ thị lồng nhau trong node editor của bạn. Hướng dẫn này cung cấp tổng quan về cách xây dựng node Module xử lý đồ thị lồng nhau dựa trên node Input/Output sử dụng phương pháp dataflow
keywords: module,nested,processing,dataflow
---

# Modules

::alert
Hướng dẫn này dựa trên [Basic](/docs/guides/basic) và [Dataflow](/docs/guides/processing/dataflow). Bạn nên xem qua để hiểu tổng thể trước khi đọc hướng dẫn này.
::
::references
:ref-example{title="Modules" link="/examples/modules"}
:ref-guide{title="Dataflow" link="/docs/guides/processing/dataflow"}
:ref-guide{title="Control flow" link="/docs/guides/processing/control-flow"}
:ref-example{title="Allmatter" link="/examples/allmatter"}
::

Hướng dẫn này trình bày các khía cạnh chính của việc xây dựng node **Module** xử lý đồ thị lồng nhau, dựa trên các node **Input** và **Output**.

Hướng dẫn này chỉ sử dụng phương pháp [Dataflow](/docs/guides/processing/dataflow) để đơn giản hóa việc hiểu code. Sau khi nắm được hướng dẫn và ví dụ, bạn có thể triển khai Control flow theo hướng dẫn [Control flow](/docs/guides/processing/control-flow).

## Chuẩn bị node {#prepare-nodes}

Ý tưởng cốt lõi của module là tạo các đồ thị riêng biệt có node **Input** và **Output**. Bước tiếp theo là tạo node **Module** chuyên biệt, phản ánh các cổng dựa trên các node loại tương ứng trong đồ thị.

Đầu tiên, tạo node làm điểm nhập dữ liệu:

```ts
export class InputNode extends ClassicPreset.Node {
  public value = null;

  constructor(public key: string) {
    super("Input");

    this.addOutput("value", new ClassicPreset.Output(socket, "Number"));
  }

  data() {
    return { value: this.value };
  }
}
```

Trường `key` do người dùng định nghĩa rất quan trọng để liên kết với cổng input của node **Module**. Ngoài ra, cần chỉ định thuộc tính `value` để truyền dữ liệu đầu vào.

Để module có ý nghĩa, cần có node **Output**:

```ts
export class OutputNode extends ClassicPreset.Node {
  constructor(public key: string) {
    super("Output");

    this.addInput("value", new ClassicPreset.Input(socket, "Number"));
  }

  data() {
    return {};
  }
}
```

Ở đây, phương thức `data` trả về object rỗng vì dữ liệu đầu vào có thể lấy qua phương thức `fetchInputs` mà không cần thực thi node.

Node **Module** đóng vai trò cổng vào đồ thị lồng nhau và hiển thị các cổng input/output, là node phức tạp nhất. Xem ví dụ đơn giản sau:

```ts
export class ModuleNode {
  module: null | Module<Schemes> = null;

  constructor(path: string) {
    super("Module");

    this.setModule(path);
  }

  public async setModule(path: string) {
    this.module = findModule(path);

    await removeNodeConnections(this.id);

    if (this.module) {
      const { inputs, outputs } = this.module.getPorts();

      syncPorts(this, inputs, outputs);
    } else {
      syncPorts(this, [], []);
    }
  }

  async data(inputs: Record<string, any>) {
    const data = await this.module?.exec(inputs);

    return data || {};
  }
}
```

Trong đó

- Hàm `findModule` trả về object đại diện cho module, cho phép truy cập các cổng để hiển thị và thực thi đồ thị lồng nhau
- `syncPorts` cập nhật cổng input/output bằng cách xóa cổng cũ và thêm cổng mới
- Hàm `removeNodeConnections` xóa tất cả connection, cho phép xóa cổng khi cần chuyển module

Lưu ý: Khi thay đổi động các node như ví dụ với `syncPorts`, cần gọi `area.update('node', node.id)`.

Để tránh xung đột khi nhiều node **Module** dùng chung đồ thị lồng nhau, hãy khởi tạo editor và engine mới trong phương thức `module.exec`.

## Thực thi đồ thị lồng nhau {#nested-graph-execution}

Ví dụ đơn giản về cách triển khai bộ xử lý đồ thị lồng nhau:

```ts
function findModule(path: string) {
  return {
    getPorts() {
      const editor = new NodeEditor<Schemes>();

      await importGraphByPath(path, editor);

      const nodes = editor.getNodes();
      const inputs = nodes
        .filter((n): n is InputNode => n instanceof InputNode)
        .map((n) => n.key);
      const outputs = nodes
        .filter((n): n is OutputNode => n instanceof OutputNode)
        .map((n) => n.key);

      return {
        inputs,
        outputs
      };
    },
    exec: async (inputData: Record<string, any>) => {
      const engine = new DataflowEngine<Schemes>();
      const editor = new NodeEditor<Schemes>();

      editor.use(engine);

      await importGraphByPath(path, editor);

      const nodes = editor.getNodes();

      injectInputs(nodes, inputData);

      return retrieveOutputs(nodes, engine);
    }
  };
```

Trong đó

- `getPorts` lấy key của các node **Input** và **Output** rồi trả về
- `importGraphByPath` dùng để load các node và connection cần thiết cho module vào editor

Mỗi lần gọi sẽ tạo instance editor mới để tránh xung đột khi xử lý đồ thị.

Phương thức sau dùng để truyền dữ liệu đầu vào của node **Module** vào các node **Input** của đồ thị lồng nhau.

```ts
function injectInputs(
  nodes: Schemes["Node"][],
  inputData: Record<string, any>
) {
  const inputNodes = nodes.filter((node) => node instanceof InputNode);

  inputNodes.forEach((node) => {
    // lưu ý có thể không có connection đầu vào, và giả sử chỉ có tối đa một connection
    node.value = inputData[node.key] && inputData[node.key][0];
  });
}
```

Sau khi truyền dữ liệu đầu vào, bước tiếp theo là lấy output từ các node:

```ts
async function retrieveOutputs(
  nodes: Schemes["Node"][],
  engine: DataflowEngine<Schemes>
) {
  const outputNodes = nodes.filter((node) => node instanceof OutputNode);

  // có thể xử lý song song
  const outputs = await Promise.all(
    outputNodes.map(async (node) => {
      const data = await engine.fetchInputs(node.id);

      // chỉ lấy dữ liệu từ connection đầu tiên vì giả sử chỉ có một connection đầu vào
      return [node.key, data.value[0]] as const;
    })
  );

  return Object.fromEntries(outputs);
}
```

Xem kết quả hoàn chỉnh tại ví dụ [Modules](/examples/modules). Cách này cũng được triển khai trong ứng dụng [Allmatter](/examples/allmatter).
