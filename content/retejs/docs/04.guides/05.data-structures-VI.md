---
description: Tìm hiểu cách sử dụng instance NodeEditor để lưu trữ và quản lý các node và connection. Hướng dẫn này cung cấp tổng quan về cấu trúc dữ liệu mà editor sử dụng, bao gồm các phương thức nâng cao từ package rete-structures
keywords: nodeeditor,nodes,connections,incomers,outgoers,roots,leaves,predecessors,successors
---

# Data structures

Tương tự như một đồ thị, framework này chứa dữ liệu dưới dạng node và cạnh. Một lưu ý: trong thuật ngữ của editor, cạnh của đồ thị được gọi là connection.

Instance `NodeEditor` lưu dữ liệu ở dạng chuẩn hóa, cụ thể là hai danh sách riêng biệt chứa các object kiểu sau:

- `{ id: <string> }` cho node
- `{ id: <string>, source: <string>, target: <string> }` cho connection

:diagram{name="editor/node-editor" caption="NodeEditor"}

Khởi tạo editor sử dụng một scheme cơ bản, chưa có trường bổ sung nào:

```ts
import { NodeEditor, BaseSchemes, getUID } from "rete";

const editor = new NodeEditor<BaseSchemes>();
```

## Thêm node và connection {#add-nodes-and-connections}

Khi làm việc với dữ liệu đồ thị, bạn có thể tạo id tùy ý cho node và connection, hoặc dùng id có sẵn.

```ts
const a = { id: getUID() };
const b = { id: getUID() };
const connection = { id: getUID(), source: a.id, target: b.id };

await editor.addNode(a);
await editor.addNode(b);
await editor.addConnection(connection);
```

## Lấy node và connection {#retrieve-nodes-and-connections}

Chúng ta có thể lấy danh sách các node và connection vừa thêm

```ts
editor.getNodes(); // trả về [a, b]
editor.getConnections(); // trả về [connection]
```

Bạn có đầy đủ các phương thức cần thiết để xử lý đồ thị, ví dụ lấy danh sách connection đầu vào hoặc tất cả node đầu vào, như sẽ trình bày ở các phần sau.

## Connection vào/ra {#incoming-outgoing-connections}

:diagram{name="guides/data-structures/connections" caption="Connection vào/ra"}

Đoạn code sau cho thấy cách lấy danh sách connection vào và ra của một node:

```ts
const connections = editor.getConnections();

const incomingConnections = connections.filter(
  (connection) => connection.target === node.id
);
const outgoingConnections = connections.filter(
  (connection) => connection.source === node.id
);
```

## Node vào/ra {#incoming-outgoing-nodes}

:diagram{name="guides/data-structures/nodes" caption="Node vào/ra"}

Ta có thể dùng biến ở phần trước để lấy node vào hoặc ra:

```ts
const incomers = incomingConnections.map((connection) =>
  editor.getNode(connection.source)
);
const outgoers = outgoingConnections.map((connection) =>
  editor.getNode(connection.target)
);
```

Thông thường, như vậy là đủ cho các trường hợp đơn giản, nhưng nếu có nhiều hơn một connection giữa các node, cần loại bỏ trùng lặp:

```ts
Array.from(new Set(incomers));
Array.from(new Set(outgoers));
```

## Phương thức nâng cao

Các cách tiếp cận trên khá linh hoạt, nhưng bạn sẽ phải tự triển khai các phương thức nâng cao. May mắn là package [`rete-structures`](https://github.com/retejs/structures) cung cấp các phương thức này, chia thành 4 nhóm:

- **Mapping**: duyệt danh sách node và biến đổi/lọc nó
- **Sets**: kỹ thuật làm việc với đồ thị như tập hợp, gồm hợp, hiệu và giao
- **Subgraph**: đồ thị có quan hệ cha-con giữa các node
- **Traverse**: duyệt node qua connection, ví dụ lấy node vào hoặc tất cả node tiền nhiệm

:diagram{name="guides/data-structures/structures" caption="rete-structures"}

### Sử dụng {#rete-structures-usage}

Cài đặt dependency

```bash
npm i rete-structures
```

Import và khai báo như sau

```ts
import { structures } from "rete-structures";

const graph = structures(editor);

graph.nodes();
graph.connections();
```

Có nhiều phương thức khác của `graph` phục vụ các mục đích riêng, minh họa dưới đây bằng code và preview tương tác. Kết quả trả về là các node không bị loại bỏ, cũng như connection nếu cả hai node đều có mặt.

### Traverse {#traverse}

#### Roots {#roots}

Node không có connection đầu vào gọi là node gốc

```ts
structures(graph).roots();
```

:structures{id="roots"}

#### Leaves {#leaves}

Node lá là node không có connection đầu ra

```ts
structures(graph).leaves();
```

:structures{id="leaves"}

#### Incomers {#incomers}

Node đầu vào kết nối trực tiếp với node được chọn

```ts
structures(graph).incomers(selectedNodeId);
```

:structures{id="incomers" pick="e"}

#### Outgoers {#outgoers}

Node đầu ra kết nối trực tiếp với node được chọn

```ts
structures(graph).outgoers(selectedNodeId);
```

:structures{id="outgoers" pick="a"}

#### Predecessors {#predecessors}

Tất cả node đầu vào, bao gồm cả node đầu vào của node đó và tiếp tục như vậy

```ts
structures(graph).predecessors(selectedNodeId);
```

:structures{id="predecessors" pick="f"}

#### Successors {#successors}

Tất cả node đầu ra, bao gồm cả node đầu ra của node đó và tiếp tục như vậy

```ts
structures(graph).successors(selectedNodeId);
```

:structures{id="successors" pick="c"}

### Mapping {#mapping}

#### Filter {#filter}

Lọc có thể áp dụng cho cả node và connection

```ts
structures(graph).filter(
  Boolean,
  ({ source, target }) => source === selectedNodeId || target === selectedNodeId
);
```

:structures{id="filter" pick="d"}

### Sets {#sets}

Ví dụ sau minh họa trường hợp node được chọn là đồ thị thứ hai.

#### Union {#union}

Hợp của đồ thị và một node từ đồ thị này sẽ trả về chính đồ thị đó

```ts
structures(editor).union({ nodes: [selectedNode], connections: [] });
```

:structures{id="union" pick="d"}

#### Difference {#difference}

Trừ node khỏi đồ thị sẽ tạo ra đồ thị mới không có node đó

```ts
structures(editor).difference({ nodes: [selectedNode], connections: [] });
```

:structures{id="union" pick="d"}

#### Intersection {#intersection}

Giao giữa đồ thị và node từ đồ thị này sẽ tạo ra đồ thị chỉ gồm node được chọn

```ts
structures(editor).intersection({ nodes: [selectedNode], connections: [] });
```

:structures{id="intersection" pick="d"}

### Subgraph {#subgraph}

Nhóm này liên quan đến đồ thị có node có quan hệ cha-con, cụ thể là node có trường `parent` và được lồng trong node khác.

#### Children {#children}

Danh sách các node con trực tiếp

```ts
structures(editor).children((n) => n.id === selectedNodeId);
```

:structures{id="children" pick="nestedParent"}

#### Parent {#parent}

Danh sách các node cha

```ts
structures(editor).parents((n) => n.id === selectedNodeId);
```

:structures{id="parent" pick="a"}

#### Descendants {#descendants}

Danh sách tất cả các node con, gồm con, cháu và các thế hệ tiếp theo

```ts
structures(editor).descendants((n) => n.id === selectedNodeId);
```

:structures{id="descendants" pick="rootParent"}

#### Ancestors {#ancestors}

Danh sách tất cả các node tổ tiên, từ cha đến ông bà và xa hơn

```ts
structures(editor).ancestors((n) => n.id === selectedNodeId);
```

:structures{id="ancestors" pick="a"}

#### Orphans {#orphans}

Node không có thuộc tính `parent`

```ts
structures(editor).orphans();
```

:structures{id="orphans"}

#### Siblings {#siblings}

Node có cùng cha với node được chọn, kể cả khi node đó không có cha

```ts
structures(editor).siblings((n) => n.id === selectedNodeId);
```

:structures{id="siblings" pick="b"}
