---
description: Khám phá các câu hỏi thường gặp về Rete.js với tài liệu FAQ này. Tìm hiểu về phát triển plugin, xử lý phía server, giấy phép và nhiều hơn nữa
keywords:
---

# FAQ

::questions
  ::qa{question="Làm thế nào để phát triển plugin riêng của tôi?" id="own-plugin"}
    Xem [hướng dẫn](/docs/development#create-plugin) về Rete Kit
  ::
  ::qa{question="Có thể xử lý đồ thị phía server, ví dụ như Node.js không?" id="server-side"}
    Có, hãy làm theo hướng dẫn [Dataflow](/docs/guides/processing/dataflow) hoặc [Control flow](/docs/guides/processing/control-flow)
  ::
  ::qa{question="Có thể xử lý đồ thị bằng Python hoặc các ngôn ngữ lập trình phía server khác không?" id="processing-on-different-langs"}
    Engine chỉ hỗ trợ runtime JS. Bạn có thể tích hợp JS vào môi trường của mình hoặc tự triển khai engine giống như `rete-engine` (cách triển khai khá đơn giản)
  ::
  ::qa{question="Framework có thể dùng cho mục đích thương mại không?" id="use-for-commercial"}
    Ngắn gọn là có. Tham khảo [Licensing](/docs/licensing) để biết chi tiết
  ::
  ::qa{question="Tôi có thể dùng framework nếu không biết TypeScript không?" id="no-typescript"}
    Có thể dùng với mã JS, nhưng không khuyến khích vì trải nghiệm lập trình sẽ kém
  ::
  ::qa{question="Có cách nào lưu đồ thị thành file JSON không?" id="save-to-json"}
    Có, hãy làm theo hướng dẫn [Import/export](/docs/guides/import-export)
  ::
  ::qa{question="Làm sao để tắt chức năng ngăn cuộn (scroll prevention)?" id="scroll-prevented"}
    Thay thế zoom handler bằng `null` hoặc dùng handler tuỳ chỉnh

    ```ts
    const area = new AreaPlugin(container)

    area.area.setZoomHandler(null)
    ```
  ::
  ::qa{question="Làm sao để bật/tắt zoom một cách động?" id="dynamic-zoom"}
    Thay thế zoom handler bằng `null` khi có sự kiện và khôi phục lại khi ngược lại (ví dụ nhấn/thả Ctrl)

    ```ts
    import { Zoom } from 'rete-area-plugin'

    // gọi khi khởi tạo
    area.area.setZoomHandler(null)

    // gọi khi nhấn Ctrl
    area.area.setZoomHandler(new Zoom(0.1))

    // gọi khi thả Ctrl
    area.area.setZoomHandler(null)
    ```
  ::
  ::qa{question="Làm sao để pan area bằng nút giữa chuột?" id="pan-middle-mouse-button"}
    Thay thế drag handler cho area cụ thể bằng cách gọi `setDragHandler`

    ```ts
      import { Drag } from 'rete-area-plugin';

      area.area.setDragHandler(new Drag({
        down: e => {
          if (e.pointerType === 'mouse' && e.button !== 1) return false

          e.preventDefault()
          return true
        },
        move: () => true
      }))
    ```
  ::
  ::qa{question="Làm sao lấy vị trí của node?"}
    Vị trí được lưu trong instance `NodeView`.

    ```ts
      const view = area.nodeViews.get(nodeId)

      if (view) {
        view.position // { x, y }
      }
    ```

    Lưu ý rằng instance `NodeView` có thể chưa tồn tại, ví dụ nếu node chưa được thêm vào. Khi đó nên xử lý hợp lý (chỉ throw exception khi thực sự cần)
  ::
  ::qa{question="Làm sao để di chuyển node/thay đổi vị trí node?"}
    ```ts
      area.translate(nodeId, { x: 0, y: 0 })
    ```
  ::
  ::qa{question="Làm sao tự động sắp xếp vị trí các node?" id="arrange-nodes"}
    Làm theo hướng dẫn Arrange nodes
  ::
  ::qa{question="Làm sao để force update node hoặc control?" id="force-update"}
    Gọi các phương thức sau cho node hoặc control tương ứng sau khi thay đổi state

    ```ts
    const area = new AreaPlugin(container)

    area.update('node', node.id)
    area.update("control", control.id);
    ```
  ::
  ::qa{question="Làm sao render nhiều node hoặc control bằng Angular, React, Vue trong cùng một editor?" id="various-render-plugins"}
    Xem Combining render plugins trong bài Integration
  ::
  ::qa{question="Làm sao thêm phần tử tuỳ chỉnh vào area của editor?" id="add-custom-elements-to-area"}
    Sử dụng các phương thức của thuộc tính content của area plugin

    ```ts
    const area = new AreaPlugin(container)

    area.content.add(element)

    area.content.remove(element)
    ```
    Bạn cũng có thể làm cho phần tử này kéo thả được

    ```ts
    const dragHandler = new Drag()

    dragHandler.initialize(element, { /* getters */ }, { /* events */ })
    ```
  ::
  ::qa{question="Làm sao tuỳ chỉnh node?" id="customize-node"}
    Xem hướng dẫn tuỳ chỉnh tương ứng cho React.js, Vue.js, Angular, Svelte hoặc Lit.
  ::
  ::qa{question="Làm sao thu nhỏ node (ẩn control để giảm kích thước node)?" id="collapse-node"}
    Định nghĩa cách ẩn các phần tử khi node bị thu nhỏ bằng cách tạo component node tuỳ chỉnh.

    Xem hướng dẫn tuỳ chỉnh tương ứng cho React.js, Vue.js, Angular, Svelte hoặc Lit.
  ::
  ::qa{question="Các bước để tự triển khai render plugin cho framework khác là gì?" id="new-render-plugins"}
    - Setup plugin
    - Tham khảo mã nguồn các package: [React.js](https://github.com/retejs/react-plugin), [Vue.js](https://github.com/retejs/vue-plugin), [Angular](https://github.com/retejs/angular-plugin), [Svelte](https://github.com/retejs/svelte-plugin) hoặc [Lit](https://github.com/retejs/lit-plugin)

  ::
  ::qa{question="Có cách nào ngăn node bị di chuyển khi thao tác với control không?" id="prevent-node-movement-on-control"}
    Bạn cần dừng lan truyền sự kiện `pointerdown`.

    Xem hướng dẫn render plugin tương ứng cho control: React.js, Vue.js, Angular, Svelte, Lit

  ::
  ::qa{question="Tại sao control không nhận được sự kiện click/pointer?" id="click-event-doesnt-work-on-control"}
    Mặc định, area sẽ bắt các sự kiện này, bạn cần dừng lan truyền sự kiện `pointerdown` để tránh điều này

    Xem hướng dẫn render plugin tương ứng cho control: React.js, Vue.js, Angular, Svelte, Lit
  ::
  ::qa{question="Có cách nào để chọn được text trong node không?" id="user-select"}
    Mặc định, node được thiết lập CSS `user-select: none` để tránh xung đột giữa chọn text và kéo node.

    Để cho phép chọn text trong node tuỳ chỉnh, bạn cần đặt thuộc tính `user-select: all` cho phần tử mong muốn trong node. Đồng thời, đảm bảo gọi `e.stopPropagation()` trên sự kiện `pointerdown` để tránh bị ngắt khi kéo.
  ::
  ::qa{question="Làm sao phát hiện click lên node?" id="nodepicked"}
    Khi người dùng click vào node, sự kiện `nodepicked` sẽ được phát:

    ```ts
    area.addPipe(context => {
      if (context.type === 'nodepicked') {
        const node = editor.getNode(context.data.id)

      }
      return context
    })
    ```

    Nếu bạn muốn theo dõi cả việc chọn node, bạn có thể mở rộng selector để quan sát các phần tử được chọn (không chỉ node) trong editor
  ::
  ::qa{question="Làm sao thêm input, output hoặc control một cách động?" id="add-inputs-outputs-controls-dynamically"}
     Bạn có thể thêm như bình thường bằng các phương thức `addInput`/`addOutput`/`AddControl`, sau đó force update node

    ```ts
    const area = new AreaPlugin(container)

    area.update('node', node.id)
    ```
  ::
  ::qa{question="Làm sao thêm control vào output?" id="add-control-to-output"}
    Việc thêm các phần tử như vậy cần tạo node tuỳ chỉnh.

    Xem hướng dẫn tuỳ chỉnh tương ứng cho React.js, Vue.js, Angular, Svelte hoặc Lit.
  ::
  ::qa{question="Làm sao tạo đồ thị không hướng với node không có socket input/output?" id="undirected-graph"}
    Bạn có thể dùng classic preset với node tuỳ chỉnh và socket thống nhất cho cả cổng input và output.

    Xem ví dụ Undirected
  ::
  ::qa{question="Làm sao để editor hiển thị theo chiều dọc?" id="vertically-oriented-editor"}
    Xem ví dụ Vertical flow
  ::
  ::qa{question="Làm sao thay đổi thứ tự input/control/output?" id="order-inputs-controls-outputs"}
    Classic rendering preset cho phép bạn chỉ định trường `index` tuỳ chọn cho input, output hoặc control. Tính năng này giúp bạn thay đổi thứ tự các phần tử trong danh sách.

    ```ts
    const input = new ClassicPreset.Input(socket)
    const output = new ClassicPreset.Output(socket)
    const control = new ClassicPreset.InputControl('text')

    input.index = 0;
    output.index = 0;
    control.index = 0;
    ```
  ::
  ::qa{question="Làm sao thay đổi căn chỉnh input/output?" id="align-inputs-outputs"}
    Việc thay đổi layout node cần tạo node tuỳ chỉnh.

    Xem hướng dẫn tuỳ chỉnh tương ứng cho React.js, Vue.js, Angular, Svelte hoặc Lit.
  ::
  ::qa{question="Có thể render UI chỉ với vanilla JS mà không dùng framework không?" id="render-vanilla-js"}
    Ngắn gọn là có thể, nhưng hiện không có plugin cho cách này vì không mang lại nhiều lợi ích so với chi phí phát triển
  ::
  ::qa{question="Cách tốt nhất để cập nhật tất cả các dependency liên quan đến `rete`?" id="update-rete-deps"}
    Nếu bạn không muốn cập nhật tất cả dependency cùng lúc với `npm update`, bạn có thể chọn lọc cập nhật các package bắt đầu bằng `rete` bằng regular expression

    ```bash
    npx npm-check-updates /^rete/ --target @latest -u
    ```
  ::
  ::qa{question="Làm sao hiển thị connection dạng vòng lặp?" id="loop-connections"}
    Tất cả plugin render đều có thể hiển thị connection dạng vòng lặp nếu có thuộc tính `isLoop`

    ```ts
    class Connection extends ClassicPreset.Connection {
      isLoop = false
    }

    const connection = new Connection(source, output, target, input)

    connection.isLoop = true
    ```
  ::
  ::qa{question="Yêu cầu tối thiểu về phiên bản TypeScript là gì?" id="minimum-ts-version"}
    Phiên bản TypeScript tối thiểu là 4.7.

    Nếu không, bạn có thể gặp lỗi `Type instantiation is excessively deep and possibly infinite. ts(2589)` khi dùng phương thức `use`. Nếu không thể dùng phiên bản mới hơn, giải pháp duy nhất là dùng `@ts-ignore`.

    Ví dụ, khi tạo ứng dụng Angular 12 với Rete Kit, một phiên bản 4.7 cao hơn bản chính thức sẽ được cài đặt.
  ::
  ::qa{question="Làm sao thay đổi mức zoom của editor bằng code?" id="zoom-area"}
    Sử dụng phương thức `area.zoom` để chỉ định mức zoom mong muốn và điểm offset để căn chỉnh zoom

    ```ts
    await area.area.zoom(0.8, 0, 0);
    ```

    Trong ví dụ trên, zoom sẽ giảm theo góc trên bên trái. Nếu muốn thay đổi zoom theo tâm viewport, tham khảo đoạn mã sau

    ```ts
    const delta = 0.2;
    const { k } = area.area.transform;
    const box = area.container.getBoundingClientRect();
    const x = box.width / 2 / k;
    const y = box.height / 2 / k;

    area.area.zoom(k * (1 - delta), x * delta, y * delta);
    ```
  ::
  ::qa{question="Làm sao thay đổi vị trí của area?" id="translate-area"}
    Sử dụng phương thức `area.translate` để thay đổi toạ độ như sau

    ```ts
    await area.area.translate(100, 20)
    ```

    Thay đổi vị trí tương đối với toạ độ hiện tại

    ```ts
    const { x, y } = area.area.transform
    await area.area.translate(x + 100, y + 20)
    ```

    Thay đổi vị trí editor có xét đến hệ số zoom

    ```ts
    const { k } = area.area.transform

    await area.area.translate(100 * k, 20 * k)
    ```
  ::
  ::qa{question="Nếu app của tôi dùng stack khác, không phải React.js, Vue.js hay Angular thì sao?" id="different-stack"}
    Nếu bạn dùng framework khác ngoài React.js, Vue.js, Angular, Svelte hoặc Lit (các framework đã có plugin render của Rete.js), bạn có thể sử dụng React.js plugin để render node và các phần tử editor.

    Để bắt đầu nhanh, bạn có thể tạo ứng dụng React.js bằng Rete Kit, copy mã editor từ `src/rete/default.tsx`, cài đặt các dependency cần thiết và gọi `createEditor`, truyền vào HTMLElement container do app của bạn tạo ra.
  ::
  ::qa{question="Làm sao lấy toạ độ tâm viewport?" id="viewport-center"}
    Đầu tiên, lấy toạ độ tâm viewport trên màn hình bằng `getBoundingClientRect`. Sau đó, chuyển đổi sang toạ độ editor bằng cách áp dụng hệ số zoom `k` và offset so với vị trí area.

    ```ts
    const area = new AreaPlugin<Schemes, AreaExtra>(container)

    const { x, y, k } = area.area.transform
    const box = area.container.getBoundingClientRect()
    const halfWidth = box.width / 2 / k
    const halfHeight = box.height / 2 / k

    return { x: halfWidth - x / k, y: halfHeight - y / k }
    ```
  ::
  ::qa{question="Cảnh báo 'Found more than one element for socket with same key and side' nghĩa là gì?" id="sockets-warning"}
    Cảnh báo "Found more than one element for socket with same key and side" nghĩa là có socket trùng lặp trong editor mà chưa được xoá đúng cách sau khi cập nhật, hoặc do cách tiếp cận bất đồng bộ khi unmount component bởi các framework UI khác nhau, vòng đời của component cũ và mới bị chồng lấp.

    Trường hợp đầu tiên, nếu số lượng cảnh báo này tăng liên tục, rất có thể bạn gặp vấn đề rò rỉ bộ nhớ vì một node tuỳ chỉnh nào đó chưa được unmount đúng cách.

    Trường hợp thứ hai, có thể tránh cảnh báo bằng cách thêm độ trễ giữa việc xoá scheme/node và mount node mới với cùng identifier. Trường hợp xấu nhất, cảnh báo này không gây rò rỉ bộ nhớ nên có thể bỏ qua.
  ::
  ::qa{question="Làm sao theo dõi sự kiện chọn hoặc bỏ chọn node?" id="select-deselect-event"}
    Framework không có sự kiện riêng cho việc này. Thay vào đó, bạn có thể [/docs/guides/selectable#extend-selector](mở rộng selector) và phát sự kiện trong các phương thức liên quan.
  ::
  ::qa{question="Làm sao ngăn/không cho zoom khi double click?" id="dblclick-prevent-zoom"}

    ```ts
      area.addPipe(context => {
        if (context.type ===  'zoom' && context.data.source === 'dblclick') return
        return context
      })
    ```
  ::
::

