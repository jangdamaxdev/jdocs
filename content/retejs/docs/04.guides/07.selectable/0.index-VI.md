---
description: Tìm hiểu cách triển khai chức năng chọn bất kỳ loại phần tử nào trong node editor của bạn. Framework cung cấp sẵn hỗ trợ chọn node, nhưng bạn cũng có thể mở rộng và tuỳ chỉnh selector để hỗ trợ các loại phần tử khác
keywords: select nodes,selectable nodes
---

# Selectable

::alert
Hướng dẫn này dựa trên [Basic](/docs/guides/basic). Bạn nên xem qua để hiểu đầy đủ nội dung của hướng dẫn này.
::

::references
:ref-example{title="Basic" link="/examples/basic"}
:ref-example{title="Lasso/marquee selection" link="/examples/lasso-marquee-selection"}
:ref-guide{title="Connections" link="/docs/guides/selectable/connections"}
:ref-guide{title="Comments" link="/docs/guides/comments#selectable"}
:ref-guide{title="Reroute" link="/docs/guides/reroute#selectable"}
:ref-github{title="Area Plugin" link="https://github.com/retejs/area-plugin"}
::

## Selectable nodes {#selectable-nodes}

Như đã giải thích trong hướng dẫn [Basic](/docs/guides/basic#selectable-nodes), bạn có thể bật chức năng chọn node bằng cách sử dụng extension `selectableNodes`

```ts
const selector = AreaExtensions.selector();
const accumulating = AreaExtensions.accumulateOnCtrl();

AreaExtensions.selectableNodes(area, selector, { accumulating });
```

Đoạn mã trên cho phép người dùng chọn nhiều node bằng cách giữ phím Ctrl, sau đó các node này có thể được di chuyển cùng nhau

## Selection or deselecting {#select-deselect}

Ngoài thao tác của người dùng, một node có thể được chọn hoặc bỏ chọn thông qua các phương thức tích hợp của `selectableNodes`

```ts
const selectableNodes = AreaExtensions.selectableNodes(area, selector, {
  accumulating,
});

selectableNodes.select(nodeId); // chọn một node, các lựa chọn trước đó sẽ bị xoá
selectableNodes.select(nodeId, true); // chọn một node mà không xoá các lựa chọn trước đó
selectableNodes.unselect(nodeId); // xoá node khỏi danh sách đã chọn
```

## Selectable custom elements {#selectable-custom-elements}

Tất cả các phần tử được thêm vào area đều có thể được thêm vào selector. Chúng có thể hoạt động như node: có thể được chọn và di chuyển cùng các phần tử khác đang được chọn

Hãy xem ví dụ về việc thêm một phần tử vào selector

```ts
const id = "element-id";
const label = "element-type";

selector.add(
  {
    id,
    label,
    translate(dx, dy) {
      // thay đổi vị trí của phần tử hiện tại theo dx,dy
    },
    unselect() {
      // được gọi khi phần tử bị xoá khỏi selector
      // tại đây bạn có thể cập nhật lại style
    },
  },
  accumulating.active()
);
```

Sau khi hoàn thành bước này, hàm `translate` sẽ được gọi mỗi khi một node hoặc phần tử được chọn khác được di chuyển.

Trước khi làm cho các phần tử được chọn khác di chuyển cùng phần tử đang kéo, bạn cần đánh dấu phần tử mà người dùng đang tương tác trực tiếp.

```ts
selector.pick({ id, label });
```

Khi một sự kiện như `pointermove` được kích hoạt trên phần tử của bạn, điều quan trọng là phải kiểm tra xem nó có phải là phần tử đang được kéo hay không, sau đó áp dụng offset cho tất cả các phần tử khác.

```ts
if (selector.isPicked({ id, label })) selector.translate(dx, dy);
```

trong đó `dx`, `dy` là offset của phần tử trong toạ độ của area. Lưu ý rằng nếu `transform.k` không bằng 1, các giá trị này sẽ lệch so với toạ độ trên màn hình.

Cách tiếp cận `pick` + `isPicked` này giúp tránh lặp vô hạn khi gọi `selector.translate` không chỉ trên sự kiện `pointermove`, mà còn khi vị trí phần tử thay đổi bằng các cách khác.

Để xoá một phần tử khỏi selector rất đơn giản:

```ts
selector.remove({ id, label });
```

## Extend selector {#extend-selector}

Ngoài hàm `AreaExtensions.selector()`, bạn còn có thể sử dụng trực tiếp class `AreaExtensions.Selector`.

```ts
const selector = new AreaExtensions.Selector();
```

Lợi ích của việc sử dụng selector dạng class là bạn có thể mở rộng và tuỳ chỉnh để bổ sung các chức năng cần thiết, như theo dõi các phần tử đã chọn hoặc bỏ chọn

```ts
import type { SelectorEntity } from "rete-area-plugin/_types/extensions/selectable";

class MySelector<E extends SelectorEntity> extends AreaExtensions.Selector<E> {
  add(entity: E, accumulate: boolean): void {
    super.add(entity, accumulate);
    console.log("added", entity);
  }
  remove(entity: E): void {
    super.remove(entity);
    console.log("removed", entity);
  }
}
```

## Other use cases {#other-use-cases}

- [Connections](/docs/guides/selectable/connections)
- [Comments](/docs/guides/comments#selectable)
- [Reroute](/docs/guides/reroute#selectable)
