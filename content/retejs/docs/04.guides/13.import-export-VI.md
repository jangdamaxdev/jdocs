---
description: Nâng cao khả năng của trình chỉnh sửa node với hướng dẫn về chức năng import/export, và hiểu sâu về các thách thức khi tuần tự hóa node/connection sang JSON
keywords: import,export,serialization,json
---

# Import/export

::references
:ref-example{title="Modules" link="/examples/modules"}
:ref-guide{title="Cấu trúc dữ liệu" link="/docs/guides/data-structures"}
:ref-example{title="3D Configurator" link="/examples/3d-configurator"}
::

Ngay từ đầu, editor có thể xử lý bất kỳ đối tượng JS nào làm node và connection, miễn là chúng có trường `id` bắt buộc cho cả hai. Ngoài ra, connection phải có trường `source` và `target`. Những đối tượng này có thể là đối tượng dữ liệu thuần hoặc đối tượng có kèm theo phương thức. Xem thêm hướng dẫn [Cấu trúc dữ liệu](/docs/guides/data-structures) để biết chi tiết.

Phiên bản hiện tại của editor không hỗ trợ import/export mặc định do một số hạn chế:

- Quá trình tuần tự hóa node/connection sang JSON có thể gặp nhiều thách thức
- Thứ tự import các node có thể khác nhau tùy vào cấu trúc đồ thị của bạn

## Đối tượng JSON hợp lệ {#valid-json}

Giả sử chúng ta có một ví dụ đơn giản, trong đó node là một đối tượng JSON hợp lệ

```ts
import { NodeEditor, BaseSchemes, getUID } from "rete";

const editor = new NodeEditor<BaseSchemes>();

const node = { id: getUID(), label: "Label" };

await editor.addNode(node);
```

Trong trường hợp này, chúng ta có thể dễ dàng export các node như vậy sang JSON để lưu vào cơ sở dữ liệu chẳng hạn.

## Đối tượng không phải JSON hợp lệ {#non-valid-json}

Những đối tượng không phải JSON hợp lệ, như instance của class, đối tượng có function, hoặc đối tượng có tham chiếu vòng lặp sẽ gây khó khăn. Loại bỏ chúng sẽ làm mất đi các lợi ích khi sử dụng JS.

Ví dụ, class node có thể được dùng để tạo node, cho phép tương tác đáng tin cậy và tiện lợi hơn thông qua các phương thức, đồng thời cung cấp sự linh hoạt để sử dụng các mô hình khác nhau.

```ts
import { ClassicPreset } from "rete";

const node = new ClassicPreset.Node("Label");

node.addOutput("port", new ClassicPreset.Output(socket, "Label"));

await editor.addNode(node);
```

Dù tuần tự hóa và giải tuần tự hóa có thể là một cách để chuyển các đối tượng như vậy thành JSON hợp lệ, nhưng cách này có thể không hiệu quả trong các trường hợp phức tạp.

## Xuất và nhập node {#import-export}

Nếu bạn muốn export một graph, bạn có thể sử dụng đoạn code sau làm tham khảo. Lưu ý rằng đây không phải là code hoàn chỉnh, mà chỉ là một phác thảo giúp bạn tự triển khai chức năng import/export phù hợp với yêu cầu của mình.

```ts
const data = { nodes: [] }
const nodes = editor.getNodes()

for (const node of nodes) {
  data.nodes.push({
    id: node.id,
    label: node.label,
    inputs: /// ....
    controls: /// ....
    outputs: /// ....
  })
}
```

Để chuyển đổi ngược lại, chúng ta phải khởi tạo các instance node, input, output và control dựa trên các đối tượng đã cung cấp.

```ts
for (const { id, label, inputs, outputs, controls } of data.nodes) {
  const node = new ClassicPreset.Node(label);

  node.id = id;

  /// ... inputs
  /// ... controls
  /// ... outputs

  await editor.addNode(node);
}
```

Bạn có thể xem ví dụ đầy đủ [tại đây](https://codesandbox.io/s/rete-js-v2-import-export-999y8z?file=/src/index.ts:3276-3465). Lưu ý rằng ví dụ này đã được đơn giản hóa để dễ hiểu hơn.

Ngoài ra, việc import/export input và output có thể không cần thiết nếu chúng là tĩnh và bạn biết loại node. Trong trường hợp đó, bạn chỉ cần lưu tên node và dữ liệu liên quan, có thể dùng để tạo instance node với các cổng đã định nghĩa sẵn. Xem thêm ví dụ [3D Configurator](/examples/3d-configurator) và [Modules](/examples/modules) với cách triển khai này.

## Thứ tự import node {#import-order}

Một thách thức khác khi import graph là thứ tự import các node. Trong trường hợp đơn giản, thứ tự sẽ giống với thứ tự bạn đã thêm node vào editor.

```ts
const graph = /// đối tượng JSON hợp lệ đã load từ DB

for (const node of graph.nodes) {
  await editor.addNode(node)
}
```

Khi làm việc với các graph phức tạp hơn, thứ tự thêm node có thể khác nhau. Ví dụ, trong một graph có node lồng nhau, có thể cần thêm node cha trước node con. Hơn nữa, người dùng có thể tạo node con trước node cha khi thao tác trên editor.

Hãy xem ví dụ import một graph mà một số node có trường `parent` chỉ ra mối liên hệ với node khác. Kết quả là các node này phải được import sau khi node cha đã được tạo.

```ts
async function importForParent(nodes, parent = undefined) {
  const nodes = nodes.filter((node) => node.parent === parent);

  for (const node of nodes) {
    await editor.addNode(node);
    await importForParent(nodes, node.id);
  }
}

const graph = /// đối tượng JSON hợp lệ đã load từ DB
  await importForParent(graph.nodes);
```

Vì cách tiếp cận này phức tạp hơn và có nhiều cách thực hiện, phương pháp import sẽ thay đổi tùy vào trường hợp sử dụng cụ thể của bạn.
