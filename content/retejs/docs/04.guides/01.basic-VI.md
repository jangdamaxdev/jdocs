---
description: Tìm hiểu cách tạo một node editor cơ bản trong ứng dụng web của bạn. Hướng dẫn này cung cấp tổng quan về các plugin cơ bản và chức năng của chúng, kèm hướng dẫn tích hợp với stack của bạn
keywords: basic,area,core
---

# Basic editor

::alert
Hướng dẫn này sử dụng `rete-react-plugin`. Bạn có thể dùng nó trong bất kỳ ứng dụng nào, bất kể framework bạn sử dụng (**React.js**, **Vue.js**, **Angular**, **Svelte**...).

Làm theo hướng dẫn này để sử dụng plugin render tương ứng trong ứng dụng **Angular**, **Svelte** hoặc **Vue.js**, tham khảo các hướng dẫn [Angular](/docs/guides/renderers/angular), [Svelte](/docs/guides/renderers/svelte), [Vue.js](/docs/guides/renderers/vue) v.v.
::

::references
:ref-example{title="Basic" link="/examples/basic"}
:ref-guide{title="Data structures" link="/docs/guides/data-structures"}
:ref-github{title="Core" link="https://github.com/retejs/rete"}
:ref-github{title="Area plugin" link="https://github.com/retejs/area-plugin"}
:ref-github{title="Connection plugin" link="https://github.com/retejs/connection-plugin"}
::

Để hoàn thành hướng dẫn này, bạn có thể tạo ứng dụng trên **[Codesandbox](https://codesandbox.io)** bằng cách chọn bất kỳ template ứng dụng client nào hoặc tự setup ứng dụng trên máy.

## Cài đặt dependencies {#install-dependencies}

:kit

```bash
npm i rete rete-area-plugin rete-connection-plugin rete-react-plugin rete-render-utils styled-components react@18 react-dom@18
```

## Định nghĩa kiểu và khởi tạo instance editor {#initialize-editor}

```ts
import { NodeEditor, GetSchemes, ClassicPreset } from "rete";

type Schemes = GetSchemes<
  ClassicPreset.Node,
  ClassicPreset.Connection<ClassicPreset.Node, ClassicPreset.Node>
>;

const editor = new NodeEditor<Schemes>();
```

Trong đó, `Schemes` là kiểu sẽ hỗ trợ bạn suy luận kiểu khi cấu hình plugin. Với các ví dụ phức tạp hơn, có thể cần mở rộng class `ClassicPreset.Node` và `ClassicPreset.Connection`.

## Thêm một node bất kỳ {#add-node}

Tạo một node có một control và một cổng output. Lưu ý rằng `addNode` là phương thức bất đồng bộ.

```ts
const socket = new ClassicPreset.Socket("socket");

const nodeA = new ClassicPreset.Node("A");
nodeA.addControl("a", new ClassicPreset.InputControl("text", {}));
nodeA.addOutput("a", new ClassicPreset.Output(socket));
await editor.addNode(nodeA);
```

## Tạo area để render với React.js {#crate-area}

Đặt đoạn code này trước khi gọi `addNode`:

```ts
import { createRoot } from "react-dom/client";
import { AreaPlugin } from "rete-area-plugin";
import { ReactPlugin, Presets, ReactArea2D } from "rete-react-plugin";

type AreaExtra = ReactArea2D<Schemes>;

const area = new AreaPlugin<Schemes, AreaExtra>(container);
const render = new ReactPlugin<Schemes, AreaExtra>({ createRoot });

render.addPreset(Presets.classic.setup());

editor.use(area);
area.use(render);
```

Trong đó

- `container` là HTMLElement nơi editor sẽ được gắn vào
- Kiểu `AreaExtra` cho phép thêm các phần tử view tùy chỉnh, mặc định chỉ có `node` và `connection`

## Thêm node khác {#add-another-node}

```ts
const nodeB = new ClassicPreset.Node("B");
nodeB.addControl("b", new ClassicPreset.InputControl("text", {}));
nodeB.addInput("b", new ClassicPreset.Input(socket));
await editor.addNode(nodeB);
```

Tạo kết nối giữa các node này

```ts
await editor.addConnection(
  new ClassicPreset.Connection(nodeA, "a", nodeB, "b")
);
```

## Định vị node {#node-positioning}

Mặc định hai node sẽ chồng lên nhau, bạn có thể di chuyển node thứ hai.

```ts
await area.translate(nodeB.id, { x: 270, y: 0 });
```

## Kết nối tương tác {#interactive-connections}

Tính năng này cho phép người dùng tương tác với các node.

```ts
import {
  ConnectionPlugin,
  Presets as ConnectionPresets,
} from "rete-connection-plugin";

const connection = new ConnectionPlugin<Schemes, AreaExtra>();

connection.addPreset(ConnectionPresets.classic.setup());

area.use(connection);
```

## Fit viewport {#fit-viewport}

Dùng extension `zoomAt` để tự động điều chỉnh viewport vừa với tất cả node.

```ts
import { AreaExtensions } from "rete-area-plugin";

AreaExtensions.zoomAt(area, editor.getNodes());
```

Mặc định, kích thước node được tính bằng `clientWidth`/`clientHeight`. Nếu gọi hàm này ngay sau khi thêm node, có thể chưa hoạt động đúng cho tới khi phần tử hiển thị trên màn hình. Thay vào đó, bạn có thể chỉ định thuộc tính `width`/`height` trong class node, như [hướng dẫn tại bước này](/docs/guides/arrange#create-node-base).

## Chọn node {#selectable-nodes}

Các extension còn cung cấp nhiều khả năng khác, ví dụ cho phép người dùng chọn node.

```ts
AreaExtensions.selectableNodes(area, AreaExtensions.selector(), {
  accumulating: AreaExtensions.accumulateOnCtrl(),
});
```

Xem thêm chi tiết tại hướng dẫn [Selectable](/docs/guides/selectable).

## Thứ tự node {#nodes-order}

Nếu ứng dụng cho phép chọn node, người dùng có thể muốn xem node được chọn mà không bị che khuất. Để hỗ trợ điều này, có extension tự động đưa node được chọn lên trên cùng.

```ts
AreaExtensions.simpleNodesOrder(area);
```

Xem kết quả hoàn chỉnh tại ví dụ [Basic](/examples/basic/react).
