---
description: Khám phá hệ thống plugin và xem cách nó có thể cải thiện chức năng dự án của bạn. Ví dụ code minh họa cách các tín hiệu được truyền giữa plugin cha và plugin con
keywords: plugin,scope,parent,child,addpipe,signals
---

# Plugin system

::references
:ref-github{title="Source code" link="https://github.com/retejs/rete/blob/main/src/scope.ts"}
::

Plugin cung cấp khả năng bổ sung chức năng mới chủ yếu thông qua một điểm vào duy nhất. Chúng giao tiếp với nhau bằng các tín hiệu (signal) được truyền từ plugin cha xuống plugin con. Vì một plugin có thể có nhiều plugin con, các tín hiệu này sẽ được truyền theo thứ tự chúng được kết nối (điều này có thể quan trọng khi sử dụng các plugin như `rete-readonly-plugin`).

:diagram{name="plugin-system/architecture" caption="Architecture"}

Ví dụ code sau minh họa việc tạo hai scope: cha và con. Cả hai scope đều log các tín hiệu.

```ts
import { Scope } from "rete";

const parentScope = new Scope<number>("parent"); // kiểu dữ liệu sinh ra là number
const childScope = new Scope<string, [number]>("child"); // [number] là kiểu dữ liệu mong đợi từ chuỗi cha

parentScope.addPipe((context) => {
  // thêm pipe vào scope cha
  console.log("parent", context); // number

  return context;
});

childScope.addPipe((context) => {
  // thêm pipe vào scope con
  console.log("child", context); // string | number

  return context;
});

parentScope.use(childScope); // chuyển tiếp tất cả tín hiệu sang scope con

const returnedNumber = await parentScope.emit(1); // có thể emit number
const returnedString = await childScope.emit("a"); // có thể emit string
```

Hãy lưu ý rằng thứ tự của `use` và `addPipe` ảnh hưởng đến thứ tự các handler của cha và con được gọi.

Log:

```log
parent 1
child 1
child a
```

Tín hiệu có thể được sửa đổi hoặc ngăn chặn trong một số trường hợp.

:diagram{name="plugin-system/addPipe" caption="Ngăn chặn và sửa đổi"}

```ts
parentScope.addPipe((context) => {
  return context * 2;
});
childScope.addPipe((context) => {
  if (context === "b") return; // ngăn chặn truyền tiếp 'b'
  return context;
});

const doubledNumber = await parentScope.emit(1); // 2
const expectedString = await childScope.emit("a"); // 'a'
const expectedUndefined = await childScope.emit("b"); // undefined
```

Kiểu tĩnh (static typing) được sử dụng để đảm bảo rằng các tín hiệu mong đợi của plugin con tương thích với các tín hiệu sinh ra từ plugin cha.

```ts
import { Scope } from "rete";

const parentScope = new Scope<number>("parent");
const childScope = new Scope<string, [number | boolean]>("child");

parentScope.use(childScope); // Type 'boolean' không thể gán cho kiểu 'string | number'.ts(2345)
```

Plugin con có thể truy cập instance của plugin cha để truy cập trực tiếp các interface hoặc để sinh tín hiệu thay mặt plugin cha.

```ts
import { Scope } from "rete";

class Root extends Scope<number> {
  isRoot = true;
}

class Root2 extends Scope<number> {
  isRoot2 = true;
}

const parentScope = new Root("parent");
const childScope = new Scope<string, [number]>("child");

parentScope.use(childScope);

const parent = childScope.parentScope(); // instance Root, nhưng là Scope dưới góc nhìn của TS
const root = childScope.parentScope<Root>(Root); // instance Root
const wrongInstance = childScope.parentScope<Root2>(Root2); // ném ra
```
