---
description: Tìm hiểu cách sử dụng Control flow trong node editor của bạn với hướng dẫn này. Làm theo từng bước để chuẩn bị node, và hiểu cách engine quản lý luồng điều khiển
keywords: control flow,control,engine
---

# Control flow

::alert
Chưa quen với khái niệm Control flow? Xem bài [Control flow](/docs/concepts/engine#control-flow) để nắm bắt nhanh
::

::references
:ref-example{title="Control flow" link="/examples/processing/control-flow"}
:ref-github{title="Plugin" link="https://github.com/retejs/engine"}
::

## Cài đặt dependencies {#install-dependencies}

:kit

```bash
npm i rete rete-engine
```

## Chuẩn bị node {#prepare-nodes}

Hãy lấy ví dụ đơn giản về một đồ thị với hai loại node: `Log` và `Delay`. Các node này có thể thực hiện các thao tác cụ thể và truyền quyền điều khiển tới các node đầu ra theo cách nhất định.

Cuối bài có link tới ví dụ đầy đủ kèm thành phần giao diện.

Định nghĩa class node ghi log và truyền quyền điều khiển tới node đầu ra qua port `exec`:

```ts
const socket = new ClassicPreset.Socket("socket");

class Log extends ClassicPreset.Node {
  constructor(public message: string) {
    super("Log");

    this.addInput("exec", new ClassicPreset.Input(socket, "Exec", true));
    this.addOutput("exec", new ClassicPreset.Output(socket, "Exec"));
  }

  execute(input: "exec", forward: (output: "exec") => void) {
    console.log(this.message);
    forward("exec");
  }
}
```

Định nghĩa class xử lý delay, mục đích duy nhất là truyền quyền điều khiển tới node đầu ra qua port `exec` sau một khoảng thời gian nhất định:

```ts
class Delay extends ClassicPreset.Node {
  constructor(private seconds: number) {
    super("Delay");
    this.addInput("exec", new ClassicPreset.Input(socket, "Exec", true));
    this.addOutput("exec", new ClassicPreset.Output(socket, "Exec"));
  }

  execute(input: "exec" | undefined, forward: (output: "exec") => void) {
    setTimeout(() => forward("exec"), seconds * 1000);
  }
}

class Connection<
  A extends NodeProps,
  B extends NodeProps
> extends ClassicPreset.Connection<A, B> {}

type NodeProps = Start | Log | Delay;
type ConnProps =
  | Connection<Start, Log>
  | Connection<Delay, Log>
  | Connection<Log, Delay>
  | Connection<Log, Log>
  | Connection<Delay, Delay>;
type Schemes = GetSchemes<NodeProps, ConnProps>;
```

## Kết nối {#connect}

```ts
import { ControlFlowEngine } from "rete-engine";
import { NodeEditor } from "rete";

const editor = new NodeEditor<Schemes>();
const engine = new ControlFlowEngine<Schemes>();

editor.use(engine);
```

## Thêm node và connection {#add-nodes-and-connections}

Hãy thêm một chuỗi node theo dạng Log -> Delay -> Log

```ts
const log1 = new Log("log before delay");
const delay = new Delay(2);
const log2 = new Log("log after delay");

const con2 = new Connection(log1, "exec", delay, "exec");
const con3 = new Connection(delay, "exec", log2, "exec");

await editor.addNode(log1);
await editor.addNode(delay);
await editor.addNode(log2);

await editor.addConnection(con2);
await editor.addConnection(con3);
```

## Thực thi {#execution}

Node `log1` sẽ là điểm bắt đầu cho quá trình thực thi đồ thị.

```ts
engine.execute(log1.id);
```

Thao tác này sẽ gọi phương thức `execute` của class `Log`, với tham số `input` là `undefined` vì node được gọi trực tiếp, không phải truyền từ node đầu vào.

Sau đó, gọi `forward("exec")` sẽ truyền quyền điều khiển tới tất cả node đầu ra. Trong ví dụ này, node `Delay` cũng làm điều tương tự nhưng sau một khoảng delay bằng `setTimeout`.

Log:

```log
"log before delay"
// delay 2 giây
"log after delay"
```

Xem kết quả đầy đủ tại ví dụ [Control flow](/examples/processing/control-flow).
