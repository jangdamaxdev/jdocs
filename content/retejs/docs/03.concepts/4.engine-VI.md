---
description: Tìm hiểu cách triển khai xử lý đồ thị kiểu dataflow và control flow trong dự án của bạn với package rete-engine của Rete.js
keywords: engine,dataflow,control flow
---

# Engine

:diagram{name="engine/architecture" caption="Kiến trúc"}

`rete-engine` là một package triển khai hai phương pháp xử lý đồ thị: [Dataflow](#dataflow) và [Control flow](#control-flow)

### Dataflow {#dataflow}

Phương pháp dataflow chỉ tập trung vào dữ liệu, trong đó node đích sẽ yêu cầu dữ liệu từ các node đầu vào. Quá trình xử lý đồ thị diễn ra từ trái sang phải, truyền output của node này làm input cho node tiếp theo.

:diagram{name="engine/dataflow" caption="Dataflow"}

Cách tiếp cận này thường được sử dụng trong các sản phẩm có node editor như Blender.

Đoạn code dưới đây minh họa các thành phần cơ bản cần thiết để `DataflowEngine` hoạt động:

- **Node phải triển khai phương thức `data`**: phương thức này nhận dữ liệu từ các node đầu vào
- **Kết nối engine với editor**: engine sẽ đăng ký mọi node được thêm vào để xử lý sau này
- **Lấy dữ liệu node**: `fetch` sẽ bắt đầu duyệt đồ thị từ node đích và truy cập tất cả các node tiền nhiệm

```ts
import { ClassicPreset } from "rete-engine";
import { DataflowEngine } from "rete-engine";

const { Node, Socket } = ClassicPreset;

class NodeAdd extends Node<
  { left: Socket; right: Socket },
  { value: Socket },
  {}
> {
  constructor() {
    // khởi tạo controls và ports
  }

  // phương thức bắt buộc
  data(inputs: { left?: number[]; right?: number[] }): { value: number } {
    const left = inputs.left[0] || 0;
    const right = inputs.right[0] || 0;

    return {
      value: left + right,
    };
  }
}

const engine = new DataflowEngine<Schemes>();

editor.use(engine);

const nodeOutput = await engine.fetch(resultNode.id);
```

### Control flow {#control-flow}

Control flow là phương pháp duyệt node cho phép bạn xác định cách truyền quyền điều khiển sang các node tiếp theo.

:diagram{name="engine/control-flow" caption="Control flow"}

Quá trình xử lý bắt đầu từ node khởi đầu, node này sẽ xác định cách truyền quyền điều khiển qua các connection đầu ra. Ví dụ, có thể là delay hoặc rẽ nhánh. Ví dụ gần nhất là UE4 Blueprints.

```ts
import { ControlFlowEngine } from "rete-engine";

const { Node, Socket } = ClassicPreset;

class Log extends Node<{ enter: Socket }, { out: Socket }, {}> {
  constructor() {
    // khởi tạo ports
  }

  // phương thức bắt buộc
  execute(input: "enter", forward: (output: "out") => void) {
    console.log("log something");
    forward("out");
  }
}

const engine = new ControlFlowEngine<Schemes>();

editor.use(engine);

engine.execute(startNode.id);
```

## Hybrid {#hybrid}

Ngoài ra, hai phương pháp này có thể kết hợp với nhau. Ví dụ, các port tên 'exec' có thể dùng để điều khiển flow, trong khi các port khác quản lý dữ liệu.

```ts
const controlflow = new ControlFlowEngine<Schemes>((node) => {
  return {
    inputs: () => ["exec"],
    outputs: () => ["exec"],
  };
});
const dataflow = new DataflowEngine<Schemes>(({ inputs, outputs }) => {
  return {
    inputs: () => Object.keys(inputs).filter((name) => name !== "exec"),
    outputs: () => Object.keys(outputs).filter((name) => name !== "exec"),
  };
});
```

Hoặc bạn có thể sử dụng trực tiếp các class `Dataflow` và `ControlFlow`, cho phép kiểm soát chi tiết hơn quá trình xử lý đồ thị.

```ts
import { ControlFlow, Dataflow } from "rete-engine";

const control = new ControlFlow(editor);
const dataflow = new Dataflow(editor);

control.add(startNode, {
  inputs: () => [],
  outputs: () => ["exec"],
  async execute(input, forward) {
    const inputs = await dataflow.fetchInputs(startNode.id);

    forward("exec");
  },
});
dataflow.add(startNode, {
  inputs: () => ["data"],
  outputs: () => ["data"],
  data(fetchInputs) {
    const inputs = await fetchInputs();
    const data = {
      data: inputs.data[0], // truyền tiếp dữ liệu input (giả sử chỉ có một connection tới port "data")
    };

    return data;
  },
});
```

## Kết luận {#conclusion}

Phiên bản engine này đã tích hợp các phương pháp xử lý đồ thị mới và khắc phục các hạn chế của phiên bản trước, vốn chỉ tập trung vào dataflow và không hỗ trợ đệ quy.

Khi xử lý đồ thị, không có giải pháp duy nhất cho mọi trường hợp. Với các trường hợp đơn giản, bạn có thể dùng `DataflowEngine` và `ControlFlowEngine`, còn với các trường hợp phức tạp, bạn có thể dùng `ControlFlow` và `Dataflow` hoặc tự viết giải pháp riêng bằng cách nghiên cứu [mã nguồn](https://github.com/retejs/engine) của package `rete-engine`.
