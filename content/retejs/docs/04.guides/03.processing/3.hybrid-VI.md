---
description: Tìm hiểu cách kết hợp Dataflow và Control flow với hướng dẫn này. Làm theo từng bước để gán một số socket làm nguồn dữ liệu và một số socket cho phương pháp control flow
keywords: hybrid,engine,dataflow,control flow
---

# Hybrid Engine

::alert

Để có cái nhìn tổng quan về khái niệm kết hợp Dataflow và Control flow, bạn nên đọc bài [Hybrid](/docs/concepts/engine#hybrid)
::

::references
:ref-example{title="Hybrid engine" link="/examples/processing/hybrid-engine"}
:ref-example{title="Chatbot" link="/examples/chatbot"}
:ref-github{title="Plugin" link="https://github.com/retejs/engine"}
:ref-guide{title="Dataflow" link="/docs/guides/processing/dataflow"}
:ref-guide{title="Control flow" link="/docs/guides/processing/control-flow"}
::

## Cài đặt dependencies {#install-dependencies}

:kit

```bash
npm i rete rete-engine
```

## Chuẩn bị node {#prepare-nodes}

Để hoạt động đúng, tất cả các class node phải triển khai phương thức `execute` cho Control flow và phương thức `data` cho Dataflow.

Class `Start` được thiết kế để truyền quyền điều khiển và có phương thức `data` mặc định trả về một object rỗng.

```ts
const socket = new ClassicPreset.Socket("socket");

class Start extends ClassicPreset.Node {
  constructor() {
    super("Start");
    this.addOutput("exec", new ClassicPreset.Output(socket, "Exec"));
  }

  execute(_: never, forward: (output: "exec") => void) {
    forward("exec");
  }

  data() {
    return {};
  }
}
```

Bên cạnh việc nhận quyền điều khiển, class `Log` cũng có thể yêu cầu dữ liệu từ các node đầu vào qua port `message` bằng cách sử dụng phương thức `fetchInputs` của instance `DataflowEngine`.

```ts
class Log extends ClassicPreset.Node {
  constructor() {
    super("Log");

    this.addInput("exec", new ClassicPreset.Input(socket, "Exec", true));
    this.addInput("message", new ClassicPreset.Input(socket, "Text"));
    this.addOutput("exec", new ClassicPreset.Output(socket, "Exec"));
  }

  async execute(input: "exec", forward: (output: "exec") => void) {
    const inputs = (await dataflow.fetchInputs(this.id)) as {
      message: string[];
    };

    console.log((inputs.message && inputs.message[0]) || "");

    forward("exec");
  }

  data() {
    return {};
  }
}
```

Class `TextNode` chỉ có nhiệm vụ cung cấp dữ liệu và không thể nhận hoặc truyền quyền điều khiển.

```ts
class TextNode extends ClassicPreset.Node {
  constructor(private text: string) {
    super("Text");
    this.addOutput("value", new ClassicPreset.Output(socket, "Number"));
  }

  execute() {}

  data(): { value: string } {
    return {
      value: this.text,
    };
  }
}

class Connection<
  A extends NodeProps,
  B extends NodeProps
> extends ClassicPreset.Connection<A, B> {}

type NodeProps = Start | Log | TextNode;
type ConnProps = Connection<Start, Log> | Connection<TextNode, Log>;
type Schemes = GetSchemes<NodeProps, ConnProps>;
```

## Kết nối {#connect}

```ts
import { NodeEditor } from "rete";
import { DataflowEngine, ControlFlowEngine } from "rete-engine";

const editor = new NodeEditor<Schemes>();
const dataflow = new DataflowEngine<Schemes>(({ inputs, outputs }) => {
  return {
    inputs: () => Object.keys(inputs).filter((name) => name !== "exec"),
    outputs: () => Object.keys(outputs).filter((name) => name !== "exec"),
  };
});
const controlflow = new ControlFlowEngine<Schemes>(() => {
  return {
    inputs: () => ["exec"],
    outputs: () => ["exec"],
  };
});

editor.use(dataflow);
editor.use(controlflow);
```

## Thêm node và connection {#add-nodes-and-connections}

```ts
const start = new Start();
const text1 = new TextNode("log");
const log1 = new Log();

const con1 = new Connection(start, "exec", log1, "exec");
const con2 = new Connection(text1, "value", log1, "message");

await editor.addNode(start);
await editor.addNode(text1);
await editor.addNode(log1);

await editor.addConnection(con1);
await editor.addConnection(con2);
```

## Thực thi {#execution}

Node `start` sẽ là điểm bắt đầu cho quá trình thực thi đồ thị.

```ts
engine.execute(start.id);
```

Kết quả là node `start` truyền quyền điều khiển tới node `log1`, node này sẽ lấy dữ liệu từ node `text1` bằng phương thức `fetchInputs`.

Xem kết quả đầy đủ tại ví dụ [Hybrid engine](/examples/processing/hybrid-engine). Ngoài ra, bạn có thể khám phá thêm ví dụ [Chatbot](/examples/chatbot) sử dụng cách tiếp cận này.
